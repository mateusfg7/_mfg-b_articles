---
title: 'Entropia no software e a teoria da Janela Quebrada'
date: '2023-06-18'
description: 'Salvando o artigo "Entropia no software e a teoria da janela quebrada: Como afeta seu dia a dia?" de Rafael dos Santos Miguel Filho.'
category: 'Article'
tags: 'programming, management, architecture, filosofia, Clean Code, structure, productivity, project, archive'
author: 'mateusfg7'
status: 'draft'
---


# Introdu√ß√£o

?> Essa √© apenas uma transcri√ß√£o/arquivo do artigo ["Entropia no software e a teoria da janela quebrada: Como afeta seu dia a dia?"](https://chroniclesofapragmaticprogrammer.substack.com/p/entropia-no-software-e-a-teoria-da) de [Rafael dos Santos Miguel Filho](https://substack.com/@chroniclesofapragmaticprogrammer), que achei v√°lido traze-lo aqui pela sua grande utilidade e import√¢ncia. Portanto **nada do artigo a seguir foi escrito por mim**.

Sim, voc√™ ouviu direito: _Entropia no Software e a Teoria da Janela Quebrada_. Pode parecer um pouco estranho no come√ßo, talvez at√© esteja se perguntando "mas o que esses conceitos t√™m a ver com o mundo do software?". Esses dois conceitos n√£o s√£o termos comumente associados um ao outro, mas ao explorar mais a fundo, descobrimos que essas duas teorias podem oferecer uma perspectiva √∫nica sobre a gest√£o eficaz do desenvolvimento e manuten√ß√£o de software. Neste artigo, exploramos como esses dois conceitos se inter-relacionam e como podem ser utilizados para melhorar as pr√°ticas de desenvolvimento de software. 

# Entropia

Parece um termo cient√≠fico complicado, n√£o √©? N√£o se preocupe, juntos vamos desmistificar essa palavra e entender o que ela realmente significa, especialmente quando aplicada ao mundo do software. Pegue um caf√© e vamos l√°! ‚òï

Vamos come√ßar no s√©culo XIX (19), com um cientista chamado [_Rudolf Clausius_](https://pt.wikipedia.org/wiki/Rudolf_Clausius). Foi ele quem nos apresentou a entropia no mundo da termodin√¢mica. Mas como isso pode ser comparado ao desenvolvimento de software? Prometo que vamos chegar l√°, mas antes vamos entender um pouco mais sobre o que Clausius queria dizer com entropia.

Entropia, no campo da f√≠sica, **√© uma forma de medir a imprevisibilidade ou, como alguns preferem simplificar, a "desordem" dentro de um sistema**. Agora, quando falo em "desordem", n√£o quero dizer bagun√ßa no sentido comum da palavra. Na verdade, estou falando sobre como a energia est√° distribu√≠da em um sistema.

Imagine que temos uma caixa cheia de part√≠culas. Se todas essas part√≠culas estiverem concentradas em um √∫nico canto, podemos dizer que a entropia √© baixa - h√° uma certa "ordem". Mas, se as part√≠culas est√£o espalhadas de maneira aleat√≥ria por toda a caixa, a√≠ temos uma alta entropia - a distribui√ß√£o de energia √© mais "imprevis√≠vel" ou "desordenada". A natureza tende ao estado de maior entropia, ou seja, as part√≠culas ir√£o se dispersar, **_a menos que algo externo intervenha_**. √â como se a natureza gostasse de um pouco de imprevisibilidade

Agora, chegou a hora de conectar essa ideia com o mundo do software üåâ. **Quando falamos em entropia no desenvolvimento de software, estamos nos referindo a essa tend√™ncia natural dos sistemas de software de se tornarem mais complexos e "desordenados" com o passar do tempo**. E quando falo "desordem" aqui, estou falando de coisas como c√≥digo mal estruturado, documenta√ß√£o insuficiente, bugs n√£o corrigidos, _code smells_, e por a√≠ vai.

O que acontece √© que conforme o software cresce e evolui, √© preciso esfor√ßo constante para evitar que essa entropia aumente. Precisamos trabalhar para manter o sistema organizado e eficiente - similar a como as part√≠culas na caixa necessitam de uma for√ßa externa para n√£o se espalharem aleatoriamente.

Agora que entendemos rapidamente o que √© entropia, vamos entender alguns pontos que podem contribuir para o seu aumento dentro do software. Vou aproveitar essa parte para comentar algumas que, infelizmente, j√° presenciei tamb√©m na ind√∫stria de software.

# A falta de requisitos claros!

Vou compartilhar com voc√™ uma hist√≥ria que, apesar de fict√≠cia, poderia facilmente se passar na realidade de muitas equipes de desenvolvimento de software. Prometo que √© uma hist√≥ria com uma li√ß√£o valiosa para todos n√≥s: programadores, gerentes de projeto, product owners e qualquer um interessado em construir produtos de software de sucesso.

> Pense em uma startup inovadora que est√° desenvolvendo um aplicativo de entrega de alimentos. Entre os muitos recursos desse aplicativo, surge um requisito especial: a op√ß√£o de os usu√°rios compartilharem um pedido com amigos, permitindo que todos adicionem seus itens preferidos √† mesma ordem. Isso parece um diferencial competitivo incr√≠vel, n√£o √© mesmo?

No entanto, a descri√ß√£o desse requisito √© um pouco vaga e n√£o entra em detalhes sobre como essa funcionalidade deve ser implementada. Deve existir um limite de usu√°rios por pedido compartilhado? Como lidar com a divis√£o dos custos de entrega?

Nosso time de desenvolvimento, sempre buscando a efici√™ncia, interpreta o requisito da melhor forma poss√≠vel com as informa√ß√µes dispon√≠veis. Eles decidem que n√£o haver√° limites para a quantidade de usu√°rios em um pedido compartilhado, e que os custos de entrega ser√£o divididos igualmente entre todos os participantes.

Quando o recurso √© lan√ßado, a rea√ß√£o dos usu√°rios √© mista. Alguns adoram a ideia, mas outros ficam frustrados. Eles n√£o acham justo que um usu√°rio que adicionou apenas um item pequeno pague a mesma taxa de entrega de algu√©m que pediu v√°rios itens maiores. A falta de limites tamb√©m causa problemas, com pedidos gigantescos causando atrasos nas entregas.

A li√ß√£o aqui? Requisitos mal definidos podem levar a mal-entendidos, **implementa√ß√µes imprecisas** e at√© mesmo a um feedback negativo dos usu√°rios.

Portanto, **cada vez que um novo recurso √© proposto, √© fundamental n√£o aceitarmos requisitos que pare√ßam insuficientemente detalhados ou que n√£o estejam coerentes com a realidade**. Esse √© um dever compartilhado: a equipe de especialistas do dom√≠nio deve se esfor√ßar para esclarecer as funcionalidades, enquanto os gestores de tecnologia precisam estar prontos para questionar e clarificar qualquer requisito que pare√ßa vago.

_**E como isso afeta e colabora para a alta desordem do software?**_

Quando um recurso √© implementado com base em requisitos mal definidos, pode levar a um c√≥digo mal estruturado ou a uma _**arquitetura de software que n√£o est√° alinhada com a verdadeira necessidade do neg√≥cio**_. Isso pode causar problemas, como dificuldades de manuten√ß√£o, problemas de performance e at√© a introdu√ß√£o de bugs. Al√©m disso, se os desenvolvedores precisam revisitar continuamente o recurso para corrigir mal-entendidos ou implementar mudan√ßas, isso pode causar ainda mais complexidade e "desordem". 

Isso gera estresse para a equipe. Afinal, provavelmente recursos que n√£o foram planejados corretamente precisam de novas defini√ß√µes e modelagem de dados. Talvez novas tabelas precisem ser criadas, novos relacionamentos e entidades. Isso consequentemente pode gerar prazos de entregas irrealistas para correr atr√°s do preju√≠zo. Sabemos que muitas empresas deixam de lado em momentos cr√≠ticos a qualidade, muitos recursos novos ou at√© os j√° existentes podem precisar de uma revis√£o completa, **mas isso n√£o √© feito com qualidade**. Percebe a cascata de problemas gerados? **Isso √© a desordem**!

Portanto, requisitos mal definidos aumentam a entropia tanto no software quanto no neg√≥cio. Eles contribuem para um c√≥digo mais ca√≥tico e complexo e podem levar a resultados de neg√≥cios indesejados. Ao mesmo tempo, lidar com esses requisitos e suas consequ√™ncias demanda tempo e recursos, que poderiam ser usados para criar novos recursos ou melhorar outros aspectos do sistema. √â por isso que √© t√£o importante se esfor√ßar para definir claramente os requisitos desde o in√≠cio.

# M√° Comunica√ß√£o entre equipes!

Vamos explorar um outro cen√°rio bastante comum no mundo do desenvolvimento de software. Este √© especialmente relevante se voc√™ j√° fez parte de uma equipe de desenvolvimento.

Vamos visualizar uma startup, trabalhando em um aplicativo de rede social. Temos dois times, temos um desenvolvedor encarregado de construir uma [API](https://aws.amazon.com/pt/what-is/api/) que √© o cora√ß√£o do sistema de notifica√ß√£o do aplicativo, respons√°vel por alertar os usu√°rios sobre novos likes, coment√°rios e mensagens.

Por outro lado, temos outro programador, em outra equipe, cuja tarefa √© desenvolver a interface de usu√°rio (frontend) que exibir√° essas notifica√ß√µes. Este desenvolvedor depende da API para receber esses dados e exibi-los de forma intuitiva e atraente para os usu√°rios.

Agora, imagine que o desenvolvedor respons√°vel pela API, na busca pela excel√™ncia, faz algumas melhorias significativas, otimizando a forma como os dados s√£o entregues. No entanto, esquece-se de informar ao colega que depende dessa API sobre as mudan√ßas realizadas, ou sobre a nova vers√£o do servi√ßo.

O programador frontend, completamente alheio √† atualiza√ß√£o, continua a trabalhar com a vers√£o antiga da API. Quando o aplicativo √© lan√ßado, os usu√°rios come√ßam a reclamar que as notifica√ß√µes n√£o est√£o funcionando como esperado, ou at√© mesmo aparecendo de forma errada.

A situa√ß√£o acima ilustra como um simples deslize na comunica√ß√£o pode conduzir a um aumento na entropia do software. Essa disfun√ß√£o n√£o apenas introduz bugs, mas tamb√©m pode causar frustra√ß√£o e confus√£o na equipe, e pior ainda, insatisfa√ß√£o no usu√°rio final.

Portanto, a li√ß√£o aqui √© clara: **a comunica√ß√£o eficaz √© fundamental para controlar a entropia no software**. Manter todos na equipe informados sobre as mudan√ßas e atualiza√ß√µes pode evitar equ√≠vocos e garantir que todos estejam alinhados, contribuindo para um software mais eficiente e um ambiente de trabalho mais harm√¥nico.

_**E como a situa√ß√£o acima colabora para a alta desordem do software?**_

A situa√ß√£o descrita acima contribui significativamente para a alta entropia do software, ou desordem, de v√°rias maneiras. Vamos dividi-la em peda√ßos para entender melhor.

1. **C√≥digo Desatualizado ou Incompat√≠vel:** O desenvolvedor que trabalha na interface do usu√°rio est√° usando uma vers√£o desatualizada da API. Isto pode levar a inconsist√™ncias no c√≥digo, erros de compatibilidade e at√© mesmo falhas no sistema. Al√©m disso, pode haver um impacto na performance do sistema.
2. **Esfor√ßo Desnecess√°rio:** A equipe agora ter√° que gastar tempo extra corrigindo os problemas causados pela falta de comunica√ß√£o. Isso significa tempo de desenvolvimento perdido que poderia ter sido usado para adicionar novos recursos ou melhorar outros aspectos do software.
3. **Introdu√ß√£o de Bugs:** A interface do usu√°rio que depende da API desatualizada pode n√£o funcionar como esperado, levando a bugs. Dependendo da gravidade desses bugs, eles podem afetar a experi√™ncia do usu√°rio e at√© mesmo levar a perdas de dados.
4. **Insatisfa√ß√£o do Usu√°rio:** A experi√™ncia do usu√°rio pode ser prejudicada devido a funcionalidades mal implementadas ou bugs. Isso pode levar a feedback negativo, perda de usu√°rios e danos √† reputa√ß√£o do produto.

Esses fatores combinados aumentam a "desordem" ou entropia dentro do projeto de software. Eles criam uma situa√ß√£o onde a complexidade e a confus√£o dominam, dificultando a implementa√ß√£o de melhorias e corre√ß√µes. √â por isso que a boa comunica√ß√£o √© t√£o crucial!


